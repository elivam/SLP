# Erlang - язык программирования

<b>Erlang</b> - функциональный язык программирования 
с сильной динамической типизацией, главной особенностью которого является программирование на уровне отдельных процессов, коммуникация между которыми реализуется с помощью MPI(Message Passing Interface).

## <b>Для чего использут этот язык программирования</b>

Программы, написанные на Erlang выдерживают сильнейшую нагрузку и очень сопротивлятся попыткам их нейтрализвать. 

Рост частот центральных процессоров остановился. Растет количество ядер и количество узлов в кластерах. Erlang создан для максимального упрощения разработки программ которые могут использовать всю мощь многоядерных и/или много узловых систем.

Успешные примеры использования Erlanga — Jabber сервер ejabberd, web-сервер YAWS и многочисленные эксперименты, например comet-программа(специфический стиль программирования веб-сайтов, когда сервер не разрывает подключения с клиентом, а продолжает пересылать ему данные при необходимости) способная держать 1 000 000(миллион) TCP-подключений.

<b>Для чего лучше использовать</b>

Эрланг в настоящее время используется в узлах поддержки, а также в GPRS , 3G и LTE мобильных сетей по всему миру , а также Nortel и T-Mobile .

## <b>Как использовать язык</b>

Программирование на Erlang - программирование на уровне отдельных, изолированных процессов, не имеющих доступа к памяти другим.

**Типы данных**

- численные: integer, float;
 
1.  integer

Целое число со знаком. Диапазон значений не ограничен. Памяти выделяется столько, сколько нужно, чтобы хранить значение. В большинстве случаев это будет 1 машинное слово (4 байта на 32-х разрядной платформе, 8 байт на 64-х разрядной). Если число большое, и для его хранения не хватает машинного слова, то памяти выделяется больше.

> 8#0677

<i>447</i>

Число с плавающей точкой. Как и в большинстве других языков, реализованно по стандарту IEEE 754. Соответственно, занимает 8 байт памяти. Может быть представлено в разных видах.

2.  float

> -2.3e+6.

<i>-2.3e6</i>

 - атомы;
 
 Это некие константные значения, которые можно сравнивать друг с другом на предмет совпадения. 
 Используется для "сопоставления с образцом" (pattern matching) 
 
> Color1 = green.

<i>green</i>

- структуры: list, tuple, map;

1.  Кортеж

Кортеж -- структура данных, объединяющая несколько разных значений в одно. Похож на список, но в отличие от списка имеет фиксированную длину. Для эрланга характерно на первое место в кортеже ставить атом, поясняющий, какое значение в нем хранится.


> {point, 5.2, 4.6}.

<i>{point,5.2,4.6}</i>

2.  Список

Список -- основная структура данных. 

>  [1,2,3,4,5].

<i>[1,2,3,4,5]</i>


>  [red, green, blue].

<i>[red,green,blue]</i>


>  [4.5, 77, hi, "hello", <<"hello">>].

<i>[4.5,77,hi,"hello",<<"hello">>]</i>

3. Запись

Запись (record) -- улучшенный кортеж с именованными полями. 

>  -record(user, {id = 0,
>             name = "",
>             age = 0
>             }).

 - идентификаторы: pid, port, reference;
 
1. <b>pid</b> является идентификатором потока, зная который, можно отправлять потоку сообщения.

>  F = fun() -> timer:sleep(5000) end.

<i>#Fun<erl_eval.20.90072148></i>


> Pid = spawn(F).

<i><0.36.0></i>


>  Pid ! hello.

<i>hello</i>

2. <b>port</b> является идентификатором специального процесса, связанного с сокетом.

> gen_tcp:listen(8080, []).

<i>{ok,#Port<0.588>}</i>


> gen_udp:open(9090).

<i>{ok,#Port<0.593>}</i>

3. <b>reference</b> является индентификатором общего назначения, который можно использовать по своему усмотрению. Например, как ключ для хранения объекта в ets таблице. Или им можно пометить сообщение, отправленное другому потоку, и ждать ответное сообщение, помеченное тем же ключом.

> Ref = make_ref().

<i>#Ref<0.0.0.30></i>


> Pid = spawn(timer, sleep, [10000]).

<i><0.36.0></i>


> Pid ! {Ref, hello}.

<i>{#Ref<0.0.0.30>,hello} </i>
 
 - функции;
 
Функция представляет собой набор команд, которые сгруппированы вместе. Эти сгруппированные инструкции вместе выполняют определенную 
задачу. В erlang все функции возвращают значение при их вызове.

> F = fun(Val) -> Val rem 2 =:= 0 end.

<i>#Fun<erl_eval.6.90072148></i>


> lists:filter(F, [1,2,3,4,5,6]).

<i>[2,4,6]</i>

 - binary
 
Представляет собой просто последовательность байт
> Val1 = 512.

<i>512</i>


> Val2 = 768.

<i>768</i>


> Val3 = 32.

<i>32</i>


#### Например 

Функция Erlang, который использует рекурсию считать до десять:

> count_to_ten() -> do_count(0).
 
> do_count(10) -> 10;

> do_count(N) -> do_count(N + 1).

Алгоритм нахождения чисел Фибоначчи , реализованный в Erlang

> fib(0) -> 0; 

> fib(1) -> 1; 

> fib(N) when N > 1 -> fib(N - 1) + fib(N - 2).





